<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan: P2 - Text Selection Highlighting</title>
    <style>
        :root {
            --chinese-red: #8B0000;
            --chinese-gold: #FFD700;
            --jade-green: #00A86B;
            --ink-black: #2B2B2B;
            --paper-beige: #F5F5DC;
            --light-cream: #FAFAF0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, var(--paper-beige) 0%, var(--light-cream) 100%);
            color: var(--ink-black);
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.6;
            font-size: 14px;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        h1 {
            font-size: 32px;
            font-weight: 900;
            margin: 16px 0;
            padding: 16px;
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            border-bottom: 3px solid var(--chinese-gold);
        }

        h2 {
            font-size: 22px;
            font-weight: 700;
            margin: 20px 0 12px 0;
            padding: 10px 16px;
            border-left: 4px solid var(--chinese-red);
            background: rgba(139, 0, 0, 0.05);
        }

        h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 16px 0 8px 0;
            padding-left: 8px;
            border-left: 2px solid var(--chinese-gold);
        }

        h4 {
            font-size: 16px;
            font-weight: 600;
            margin: 12px 0 6px 0;
            color: var(--chinese-red);
        }

        .hero {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.1));
            border: 2px solid var(--chinese-gold);
            padding: 24px;
            margin: 24px 0;
            border-radius: 8px;
        }

        .review-summary {
            background: linear-gradient(135deg, rgba(0, 168, 107, 0.1), white);
            border: 3px solid var(--jade-green);
            padding: 20px;
            margin: 24px 0;
            border-radius: 8px;
        }

        .warning-box {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), white);
            border-left: 4px solid var(--chinese-red);
            padding: 16px;
            margin: 16px 0;
        }

        .highlight-box {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), white);
            border: 2px solid var(--chinese-gold);
            padding: 16px;
            margin: 16px 0;
            border-radius: 6px;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 16px 0;
        }

        .card {
            background: white;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 6px;
            padding: 16px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        }

        .card.priority {
            border: 2px solid var(--chinese-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), white);
        }

        .collapsible {
            margin: 12px 0;
            border: 1px solid rgba(139, 0, 0, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 12px 20px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.05), rgba(255, 215, 0, 0.02));
            border-left: 4px solid var(--chinese-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
        }

        .collapsible-header .arrow {
            transition: transform 0.3s ease;
            color: var(--chinese-red);
            font-size: 14px;
            margin-right: 8px;
        }

        .collapsible.open .arrow {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
            background: white;
        }

        .collapsible.open .collapsible-content {
            max-height: 10000px;
            padding: 20px;
        }

        pre {
            background: rgba(43, 43, 43, 0.05);
            border: 1px solid rgba(139, 0, 0, 0.1);
            border-left: 3px solid var(--chinese-red);
            padding: 16px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.6;
            margin: 12px 0;
            border-radius: 4px;
        }

        code {
            background: rgba(139, 0, 0, 0.05);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: var(--chinese-red);
        }

        ul, ol {
            margin: 12px 0;
            padding-left: 28px;
        }

        li {
            margin: 6px 0;
            line-height: 1.7;
        }

        li strong {
            color: var(--chinese-red);
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            background: var(--chinese-red);
            color: white;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            margin: 0 4px;
        }

        .badge.green { background: var(--jade-green); }
        .badge.gold { background: var(--chinese-gold); color: var(--ink-black); }
        .badge.critical { background: #b22222; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            background: white;
        }

        th, td {
            padding: 10px 14px;
            border: 1px solid rgba(139, 0, 0, 0.2);
            text-align: left;
        }

        th {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), rgba(255, 215, 0, 0.05));
            font-weight: 700;
            color: var(--chinese-red);
        }

        .controls {
            text-align: right;
            margin: 12px 0;
        }

        button {
            background: linear-gradient(135deg, var(--chinese-red), #CD5C5C);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 6px 16px;
            margin: 0 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3);
        }

        .metric {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .metric-label {
            font-weight: 600;
            margin-right: 12px;
            min-width: 180px;
        }

        .metric-value {
            color: var(--chinese-red);
            font-weight: 700;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <button onclick="expandAll()">Expand All</button>
            <button onclick="collapseAll()">Collapse All</button>
        </div>

        <h1>üìã P2: Text Selection Highlighting</h1>

        <div class="hero">
            <h2>Executive Summary</h2>
            <div class="two-column">
                <div>
                    <h3>Objective</h3>
                    <p>Add hypertext-style inline highlighting when users select text and chat with it, building on existing <code>InlineChatWindow</code> functionality.</p>
                    <div class="metric">
                        <span class="metric-label">Complexity:</span>
                        <span class="metric-value">Medium-High</span>
                    </div>
                </div>
                <div>
                    <h3>Approach</h3>
                    <p><strong>Primary:</strong> CSS Highlights API (paint-layer, non-invasive)<br>
                    <strong>Fallback:</strong> DOM wrapping with surgical precision<br>
                    <strong>Activation:</strong> Reuse Ctrl+Shift+C + context menu</p>
                </div>
            </div>
        </div>

        <div class="review-summary">
            <h2>üîç Codex Review Summary</h2>
            <div class="two-column">
                <div>
                    <h4>Critical Issues Identified</h4>
                    <ul>
                        <li><span class="badge critical">BLOCKER</span> Cmd+Shift+T reserved by browsers</li>
                        <li><span class="badge critical">RISK</span> Range.cloneRange() doesn't survive DOM mutations</li>
                        <li><span class="badge critical">RISK</span> surroundContents() breaks on complex selections</li>
                        <li><span class="badge">ISSUE</span> Overlapping highlights corrupt semantics</li>
                        <li><span class="badge">ISSUE</span> Style injection CSP violations</li>
                        <li><span class="badge">ISSUE</span> No dark mode consideration</li>
                        <li><span class="badge">ISSUE</span> Context extraction across nodes complex</li>
                    </ul>
                </div>
                <div>
                    <h4>Changes Made</h4>
                    <ul>
                        <li><span class="badge green">FIXED</span> Use existing Ctrl+Shift+C shortcut</li>
                        <li><span class="badge green">FIXED</span> CSS Highlights API as primary approach</li>
                        <li><span class="badge green">FIXED</span> Serialize selections (Text Position Selector)</li>
                        <li><span class="badge green">FIXED</span> Prevent overlapping via highlight registry</li>
                        <li><span class="badge green">ADDED</span> Accessible color palettes</li>
                        <li><span class="badge green">ADDED</span> Safe text node traversal</li>
                        <li><span class="badge green">ADDED</span> Scope-limited MutationObserver</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><span class="arrow">‚ñ∂</span>üìç Prerequisites & Current State</span>
            </div>
            <div class="collapsible-content">
                <h3>Existing Infrastructure</h3>
                <ul>
                    <li><strong>InlineChatWindow</strong> (<code>src/components/InlineChatWindow.tsx</code>)
                        <ul>
                            <li>Floating chat window in content script</li>
                            <li>Supports both page context and element-specific context</li>
                            <li>Activated by Ctrl+Shift+C keyboard shortcut</li>
                        </ul>
                    </li>
                    <li><strong>Content Script</strong> (<code>src/content/index.tsx</code>)
                        <ul>
                            <li>Handles OPEN_INLINE_CHAT message from background</li>
                            <li>Mounts InlineChatWindow in Shadow DOM</li>
                        </ul>
                    </li>
                    <li><strong>Background Worker</strong> (<code>src/background/index.ts</code>)
                        <ul>
                            <li>Registers Ctrl+Shift+C command</li>
                            <li>Can add context menu handlers</li>
                        </ul>
                    </li>
                </ul>

                <h3>Files to Examine</h3>
                <table>
                    <tr>
                        <th>File</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td><code>src/components/InlineChatWindow.tsx</code></td>
                        <td>Understand current context handling</td>
                    </tr>
                    <tr>
                        <td><code>src/content/index.tsx</code></td>
                        <td>Message handling, Shadow DOM setup</td>
                    </tr>
                    <tr>
                        <td><code>src/background/index.ts</code></td>
                        <td>Command registration, context menu</td>
                    </tr>
                    <tr>
                        <td><code>src/types/elementChat.ts</code></td>
                        <td>Session type definitions</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="collapsible open">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><span class="arrow">‚ñ∂</span>‚ö° Implementation Steps</span>
            </div>
            <div class="collapsible-content">
                <h3>Phase 1: Detection & Activation (Day 1)</h3>

                <div class="card priority">
                    <h4>Step 1: Extend Background Worker Context Menu</h4>
                    <p><strong>File:</strong> <code>src/background/index.ts</code></p>
                    <pre>// Add context menu for text selections
chrome.runtime.onInstalled.addListener(() => {
  chrome.contextMenus.create({
    id: 'nabokov-chat-with-selection',
    title: 'Chat with selection',
    contexts: ['selection']
  });
});

chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === 'nabokov-chat-with-selection' && tab?.id) {
    chrome.tabs.sendMessage(tab.id, {
      type: 'OPEN_INLINE_CHAT',
      mode: 'text-selection',  // NEW: distinguish from page chat
      selectionText: info.selectionText
    });
  }
});</pre>
                    <p><strong>Testing:</strong> Right-click selected text ‚Üí verify menu item appears</p>
                </div>

                <div class="card priority">
                    <h4>Step 2: Modify Ctrl+Shift+C Handler</h4>
                    <p><strong>File:</strong> <code>src/background/index.ts</code></p>
                    <pre>chrome.commands.onCommand.addListener((command) => {
  if (command === 'toggle-inline-chat') {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]?.id) {
        chrome.tabs.sendMessage(tabs[0].id, {
          type: 'OPEN_INLINE_CHAT',
          mode: 'auto-detect'  // NEW: detect text selection vs. page chat
        });
      }
    });
  }
});</pre>
                    <p><strong>Testing:</strong> Press Ctrl+Shift+C with/without selection ‚Üí correct mode</p>
                </div>

                <div class="card priority">
                    <h4>Step 3: Detect Selection in Content Script</h4>
                    <p><strong>File:</strong> <code>src/content/index.tsx</code></p>
                    <pre>chrome.runtime.onMessage.addListener((message) => {
  if (message.type === 'OPEN_INLINE_CHAT') {
    const selection = window.getSelection();
    const hasSelection = selection &&
      selection.toString().trim().length > 0;

    const mode = message.mode === 'auto-detect'
      ? (hasSelection ? 'text-selection' : 'page')
      : message.mode;

    if (mode === 'text-selection') {
      if (!hasSelection) {
        console.warn('[InlineChat] No text selected');
        return;
      }
      handleTextSelectionChat(selection);
    } else {
      handlePageChat();
    }
  }
});</pre>
                    <p><strong>Testing:</strong> Auto-detect works correctly for both cases</p>
                </div>

                <h3>Phase 2: CSS Highlights API Implementation (Day 2)</h3>

                <div class="card priority">
                    <h4>Step 4: Create Text Selection Service</h4>
                    <p><strong>File:</strong> <code>src/services/textSelectionHighlightService.ts</code> (NEW)</p>
                    <pre>import { generateId } from '@/utils/storage';

// Check if CSS Highlights API is available
const supportsHighlightsAPI = 'highlights' in CSS;

interface TextSelectionSession {
  id: string;
  serializedRange: TextPositionSelector;
  selectedText: string;
  state: 'loading' | 'active' | 'error';
  createdAt: number;
  highlight?: Highlight; // CSS Highlights API
  fallbackSpan?: HTMLElement; // DOM wrapping fallback
}

interface TextPositionSelector {
  type: 'TextPositionSelector';
  start: number;
  end: number;
  textContent: string; // For validation
}

const sessions = new Map<string, TextSelectionSession>();

export function createTextSelectionSession(
  selection: Selection
): TextSelectionSession | null {
  if (!selection.rangeCount) return null;

  const range = selection.getRangeAt(0);
  const selectedText = range.toString().trim();

  if (!selectedText) return null;

  // Serialize range for persistence
  const serialized = serializeRange(range);
  if (!serialized) return null;

  const session: TextSelectionSession = {
    id: generateId(),
    serializedRange: serialized,
    selectedText,
    state: 'loading',
    createdAt: Date.now()
  };

  sessions.set(session.id, session);
  return session;
}

function serializeRange(range: Range): TextPositionSelector | null {
  // Get the root text content
  const root = document.body;
  const textContent = root.textContent || '';

  // Calculate text position offsets
  const startOffset = getTextOffset(root, range.startContainer, range.startOffset);
  const endOffset = getTextOffset(root, range.endContainer, range.endOffset);

  if (startOffset === null || endOffset === null) return null;

  return {
    type: 'TextPositionSelector',
    start: startOffset,
    end: endOffset,
    textContent: range.toString()
  };
}

function getTextOffset(
  root: Node,
  node: Node,
  offset: number
): number | null {
  // Walk the tree and count text characters
  const walker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_TEXT,
    null
  );

  let totalOffset = 0;
  let currentNode: Text | null;

  while (currentNode = walker.nextNode() as Text | null) {
    if (currentNode === node) {
      return totalOffset + offset;
    }
    totalOffset += currentNode.textContent?.length || 0;
  }

  return null;
}</pre>
                </div>

                <div class="card priority">
                    <h4>Step 5: Apply CSS Highlights</h4>
                    <p><strong>File:</strong> <code>src/services/textSelectionHighlightService.ts</code></p>
                    <pre>export function applyHighlight(
  sessionId: string,
  state: 'loading' | 'active' | 'error'
): boolean {
  const session = sessions.get(sessionId);
  if (!session) return false;

  session.state = state;

  if (supportsHighlightsAPI) {
    return applyHighlightAPI(session);
  } else {
    return applyFallbackHighlight(session);
  }
}

function applyHighlightAPI(session: TextSelectionSession): boolean {
  try {
    // Deserialize range from text position
    const range = deserializeRange(session.serializedRange);
    if (!range) return false;

    // Create CSS Highlight
    const highlight = new Highlight(range);
    CSS.highlights.set(`nabokov-selection-${session.id}`, highlight);

    session.highlight = highlight;

    // Apply styles via CSS
    injectHighlightStyles(session.id, session.state);

    return true;
  } catch (error) {
    console.error('[Highlight] CSS Highlights API failed:', error);
    return false;
  }
}

function deserializeRange(selector: TextPositionSelector): Range | null {
  const root = document.body;
  const textContent = root.textContent || '';

  // Validate that text content matches
  const actualText = textContent.slice(selector.start, selector.end);
  if (actualText !== selector.textContent) {
    console.warn('[Highlight] Text content mismatch, page may have changed');
    // Try to find the text anyway
  }

  // Walk tree to find start and end nodes
  const walker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_TEXT,
    null
  );

  let currentOffset = 0;
  let startNode: Text | null = null;
  let startOffset = 0;
  let endNode: Text | null = null;
  let endOffset = 0;
  let node: Text | null;

  while (node = walker.nextNode() as Text | null) {
    const length = node.textContent?.length || 0;

    if (!startNode && currentOffset + length > selector.start) {
      startNode = node;
      startOffset = selector.start - currentOffset;
    }

    if (!endNode && currentOffset + length >= selector.end) {
      endNode = node;
      endOffset = selector.end - currentOffset;
      break;
    }

    currentOffset += length;
  }

  if (!startNode || !endNode) return null;

  const range = document.createRange();
  range.setStart(startNode, startOffset);
  range.setEnd(endNode, endOffset);

  return range;
}

function injectHighlightStyles(sessionId: string, state: string) {
  const existingStyle = document.getElementById('nabokov-highlight-styles');
  if (existingStyle) {
    existingStyle.remove();
  }

  const colors = getStateColors(state);

  const style = document.createElement('style');
  style.id = 'nabokov-highlight-styles';
  style.textContent = `
    ::highlight(nabokov-selection-${sessionId}) {
      background-color: ${colors.background};
      text-decoration: underline 2px ${colors.underline};
      text-decoration-skip-ink: none;
    }
  `;

  document.head.appendChild(style);
}

function getStateColors(state: string): {
  background: string;
  underline: string;
} {
  // Check for dark mode
  const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

  switch (state) {
    case 'loading':
      return {
        background: isDark ? 'rgba(108, 108, 108, 0.2)' : 'rgba(108, 108, 108, 0.1)',
        underline: isDark ? 'rgba(108, 108, 108, 0.8)' : 'rgba(108, 108, 108, 0.6)'
      };
    case 'active':
      return {
        background: isDark ? 'rgba(177, 64, 60, 0.25)' : 'rgba(177, 64, 60, 0.15)',
        underline: isDark ? 'rgba(177, 64, 60, 0.9)' : 'rgba(177, 64, 60, 0.6)'
      };
    case 'error':
      return {
        background: isDark ? 'rgba(178, 34, 34, 0.25)' : 'rgba(178, 34, 34, 0.15)',
        underline: isDark ? 'rgba(178, 34, 34, 0.9)' : 'rgba(178, 34, 34, 0.6)'
      };
    default:
      return { background: 'transparent', underline: 'transparent' };
  }
}</pre>
                </div>

                <div class="card">
                    <h4>Step 6: DOM Wrapping Fallback (Browsers without CSS Highlights API)</h4>
                    <p><strong>File:</strong> <code>src/services/textSelectionHighlightService.ts</code></p>
                    <pre>function applyFallbackHighlight(session: TextSelectionSession): boolean {
  try {
    const range = deserializeRange(session.serializedRange);
    if (!range) return false;

    // Check if selection is safe to wrap
    if (!isSafeToWrap(range)) {
      console.warn('[Highlight] Selection not safe to wrap');
      return false;
    }

    // Create wrapper span
    const span = document.createElement('span');
    span.className = 'nabokov-text-highlight';
    span.dataset.sessionId = session.id;
    span.dataset.state = session.state;

    // Apply inline styles
    const colors = getStateColors(session.state);
    Object.assign(span.style, {
      backgroundColor: colors.background,
      textDecoration: `underline 2px ${colors.underline}`,
      textDecorationSkipInk: 'none',
      cursor: 'pointer',
      position: 'relative'
    });

    // Try to wrap
    try {
      range.surroundContents(span);
    } catch (e) {
      // Fallback: extract and append
      const contents = range.extractContents();
      span.appendChild(contents);
      range.insertNode(span);
    }

    // Add click handler to reopen chat
    span.addEventListener('click', () => {
      handleHighlightClick(session.id);
    });

    session.fallbackSpan = span;
    return true;
  } catch (error) {
    console.error('[Highlight] Fallback wrapping failed:', error);
    return false;
  }
}

function isSafeToWrap(range: Range): boolean {
  // Don't wrap if selection spans multiple block elements
  const startBlock = getBlockParent(range.startContainer);
  const endBlock = getBlockParent(range.endContainer);

  if (startBlock !== endBlock) {
    return false;
  }

  // Don't wrap inside interactive elements
  const container = range.commonAncestorContainer;
  const parent = container.nodeType === Node.ELEMENT_NODE
    ? container as Element
    : container.parentElement;

  if (!parent) return false;

  const interactive = parent.closest('a, button, input, textarea, select');
  if (interactive) {
    return false;
  }

  return true;
}

function getBlockParent(node: Node): Element | null {
  let current = node.nodeType === Node.ELEMENT_NODE
    ? node as Element
    : node.parentElement;

  while (current) {
    const display = window.getComputedStyle(current).display;
    if (display === 'block' || display === 'flex' || display === 'grid') {
      return current;
    }
    current = current.parentElement;
  }

  return null;
}</pre>
                </div>

                <h3>Phase 3: Integration with InlineChatWindow (Day 3)</h3>

                <div class="card priority">
                    <h4>Step 7: Handle Text Selection Chat</h4>
                    <p><strong>File:</strong> <code>src/content/index.tsx</code></p>
                    <pre>async function handleTextSelectionChat(selection: Selection) {
  // Create session
  const session = textSelectionHighlightService.createTextSelectionSession(selection);
  if (!session) {
    console.warn('[InlineChat] Failed to create text selection session');
    return;
  }

  // Apply highlight (loading state)
  const highlighted = textSelectionHighlightService.applyHighlight(
    session.id,
    'loading'
  );

  if (!highlighted) {
    console.warn('[InlineChat] Failed to apply highlight');
    // Continue anyway, just without visual feedback
  }

  // Build context
  const context = buildTextSelectionContext(session);

  // Open InlineChatWindow
  openInlineChatWindow({
    mode: 'text-selection',
    sessionId: session.id,
    context,
    selectedText: session.selectedText,
    onStateChange: (state) => {
      textSelectionHighlightService.applyHighlight(session.id, state);
    },
    onClose: () => {
      textSelectionHighlightService.removeHighlight(session.id);
    }
  });

  // Update to active state
  textSelectionHighlightService.applyHighlight(session.id, 'active');
}

function buildTextSelectionContext(
  session: TextSelectionSession
): string {
  const parts: string[] = [];

  parts.push(`URL: ${window.location.href}`);
  parts.push(`Title: ${document.title}`);
  parts.push(`\nSelected Text:\n${session.selectedText}`);

  // Get surrounding context (500 chars before/after)
  const selector = session.serializedRange;
  const fullText = document.body.textContent || '';

  const beforeStart = Math.max(0, selector.start - 500);
  const afterEnd = Math.min(fullText.length, selector.end + 500);

  const beforeText = fullText.slice(beforeStart, selector.start);
  const afterText = fullText.slice(selector.end, afterEnd);

  if (beforeText) {
    parts.push(`\nContext Before:\n...${beforeText}`);
  }
  if (afterText) {
    parts.push(`\nContext After:\n${afterText}...`);
  }

  return parts.join('\n');
}</pre>
                </div>

                <div class="card">
                    <h4>Step 8: Remove Highlight</h4>
                    <p><strong>File:</strong> <code>src/services/textSelectionHighlightService.ts</code></p>
                    <pre>export function removeHighlight(sessionId: string) {
  const session = sessions.get(sessionId);
  if (!session) return;

  if (session.highlight) {
    // CSS Highlights API
    CSS.highlights.delete(`nabokov-selection-${sessionId}`);

    // Remove style element
    const styleEl = document.getElementById('nabokov-highlight-styles');
    if (styleEl) {
      styleEl.remove();
    }
  }

  if (session.fallbackSpan) {
    // DOM wrapping fallback - unwrap
    const parent = session.fallbackSpan.parentNode;
    if (parent) {
      while (session.fallbackSpan.firstChild) {
        parent.insertBefore(session.fallbackSpan.firstChild, session.fallbackSpan);
      }
      parent.removeChild(session.fallbackSpan);
    }
  }

  sessions.delete(sessionId);
}</pre>
                </div>

                <h3>Phase 4: Cleanup & Edge Cases (Day 4)</h3>

                <div class="card">
                    <h4>Step 9: MutationObserver for Cleanup</h4>
                    <p><strong>File:</strong> <code>src/services/textSelectionHighlightService.ts</code></p>
                    <pre>// Scope-limited observer
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.removedNodes.forEach(node => {
      // Check if any highlight spans were removed
      sessions.forEach((session, sessionId) => {
        if (session.fallbackSpan && !document.contains(session.fallbackSpan)) {
          console.log(`[Highlight] Cleaning up orphaned session: ${sessionId}`);
          sessions.delete(sessionId);
        }
      });
    });
  });
});

// Only observe specific container if possible, or limit depth
export function startObserver(root: Element = document.body) {
  observer.observe(root, {
    childList: true,
    subtree: true
  });
}

export function stopObserver() {
  observer.disconnect();
}</pre>
                </div>

                <div class="card">
                    <h4>Step 10: Handle Overlapping Highlights</h4>
                    <p><strong>File:</strong> <code>src/services/textSelectionHighlightService.ts</code></p>
                    <pre>export function hasOverlappingHighlight(
  range: Range
): string | null {
  const startOffset = getTextOffset(document.body, range.startContainer, range.startOffset);
  const endOffset = getTextOffset(document.body, range.endContainer, range.endOffset);

  if (startOffset === null || endOffset === null) return null;

  // Check all existing sessions for overlap
  for (const [sessionId, session] of sessions.entries()) {
    const existingStart = session.serializedRange.start;
    const existingEnd = session.serializedRange.end;

    // Check for overlap
    if (!(endOffset <= existingStart || startOffset >= existingEnd)) {
      return sessionId; // Found overlap
    }
  }

  return null;
}

// Use in createTextSelectionSession
export function createTextSelectionSession(
  selection: Selection,
  options: { allowOverlap?: boolean } = {}
): TextSelectionSession | null {
  // ... existing code ...

  const range = selection.getRangeAt(0);

  // Check for overlaps
  if (!options.allowOverlap) {
    const overlapping = hasOverlappingHighlight(range);
    if (overlapping) {
      console.warn('[Highlight] Overlapping highlight detected:', overlapping);
      // Option: focus existing highlight instead
      return null;
    }
  }

  // ... continue with session creation ...
}</pre>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><span class="arrow">‚ñ∂</span>‚úì Testing & Validation</span>
            </div>
            <div class="collapsible-content">
                <h3>Unit Tests</h3>
                <table>
                    <tr>
                        <th>Test</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Range serialization</td>
                        <td>serializeRange() ‚Üí deserializeRange() roundtrip</td>
                    </tr>
                    <tr>
                        <td>Text offset calculation</td>
                        <td>getTextOffset() correct for various node types</td>
                    </tr>
                    <tr>
                        <td>Safe to wrap detection</td>
                        <td>isSafeToWrap() rejects cross-block, interactive</td>
                    </tr>
                    <tr>
                        <td>Overlap detection</td>
                        <td>hasOverlappingHighlight() finds overlaps</td>
                    </tr>
                    <tr>
                        <td>State colors</td>
                        <td>getStateColors() adjusts for dark mode</td>
                    </tr>
                </table>

                <h3>E2E Tests</h3>
                <ol>
                    <li><strong>Context menu activation:</strong> Right-click selection ‚Üí menu appears ‚Üí chat opens with highlight</li>
                    <li><strong>Keyboard activation:</strong> Select text, Ctrl+Shift+C ‚Üí chat opens with highlight</li>
                    <li><strong>Auto-detect mode:</strong> Ctrl+Shift+C without selection ‚Üí page chat (no highlight)</li>
                    <li><strong>Highlight appearance:</strong> Loading (gray) ‚Üí Active (red) state transition</li>
                    <li><strong>Error state:</strong> API error ‚Üí Highlight turns bright red</li>
                    <li><strong>Remove on close:</strong> Close chat ‚Üí Highlight disappears</li>
                    <li><strong>Overlap prevention:</strong> Select overlapping text ‚Üí Warning or focus existing</li>
                    <li><strong>DOM mutation cleanup:</strong> SPA navigation ‚Üí Orphaned highlights removed</li>
                    <li><strong>Complex selections:</strong> Multi-paragraph selection ‚Üí Fallback wrapping or rejection</li>
                    <li><strong>Dark mode:</strong> Enable dark mode ‚Üí Colors adjust</li>
                </ol>

                <h3>Browser Compatibility</h3>
                <table>
                    <tr>
                        <th>Browser</th>
                        <th>CSS Highlights API</th>
                        <th>Fallback</th>
                    </tr>
                    <tr>
                        <td>Chrome 105+</td>
                        <td>‚úÖ Supported</td>
                        <td>N/A</td>
                    </tr>
                    <tr>
                        <td>Edge 105+</td>
                        <td>‚úÖ Supported</td>
                        <td>N/A</td>
                    </tr>
                    <tr>
                        <td>Firefox</td>
                        <td>‚ùå Not yet</td>
                        <td>‚úÖ DOM wrapping</td>
                    </tr>
                    <tr>
                        <td>Safari</td>
                        <td>‚ùå Not yet</td>
                        <td>‚úÖ DOM wrapping</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><span class="arrow">‚ñ∂</span>‚ö†Ô∏è Potential Issues & Mitigations</span>
            </div>
            <div class="collapsible-content">
                <div class="warning-box">
                    <h4>Issue: CSS Highlights API Not Universal</h4>
                    <p><strong>Risk:</strong> Firefox/Safari don't support it yet</p>
                    <p><strong>Mitigation:</strong> Robust DOM wrapping fallback with safety checks</p>
                </div>

                <div class="warning-box">
                    <h4>Issue: Range Serialization Fragility</h4>
                    <p><strong>Risk:</strong> Text offsets invalid after DOM mutations</p>
                    <p><strong>Mitigation:</strong> Store text content for validation, warn user if mismatch</p>
                </div>

                <div class="warning-box">
                    <h4>Issue: Complex Selections Break Wrapping</h4>
                    <p><strong>Risk:</strong> Multi-block selections corrupt page structure</p>
                    <p><strong>Mitigation:</strong> isSafeToWrap() validation, reject unsafe selections</p>
                </div>

                <div class="warning-box">
                    <h4>Issue: Performance on Large Documents</h4>
                    <p><strong>Risk:</strong> Tree walking slow on huge pages</p>
                    <p><strong>Mitigation:</strong> Limit highlights per page (e.g., max 10), cache text offsets</p>
                </div>

                <div class="warning-box">
                    <h4>Issue: Security - Style Injection</h4>
                    <p><strong>Risk:</strong> CSP violations on strict pages</p>
                    <p><strong>Mitigation:</strong> Use inline styles for fallback, check CSP before injection</p>
                </div>
            </div>
        </div>

        <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
                <span><span class="arrow">‚ñ∂</span>üìä Post-Implementation</span>
            </div>
            <div class="collapsible-content">
                <h3>Documentation Needs</h3>
                <ul>
                    <li>Update CLAUDE.md with text selection feature</li>
                    <li>Document CSS Highlights API vs. fallback behavior</li>
                    <li>Add TSDoc comments to textSelectionHighlightService</li>
                    <li>User guide: How to chat with text selections</li>
                </ul>

                <h3>Follow-up Tasks</h3>
                <ul>
                    <li>Add user preference: Disable text selection highlighting</li>
                    <li>Add limit on max highlights per page</li>
                    <li>Consider persistence: Save highlights across page reloads (Phase 2)</li>
                    <li>Investigate recovery: Re-apply highlights after SPA navigation (Phase 2)</li>
                </ul>

                <h3>Maintenance Considerations</h3>
                <ul>
                    <li>Monitor CSS Highlights API adoption in Firefox/Safari</li>
                    <li>Track DOM wrapping fallback usage metrics</li>
                    <li>Watch for user reports of broken page functionality</li>
                    <li>Update color palettes based on accessibility feedback</li>
                </ul>
            </div>
        </div>

        <div class="highlight-box">
            <h2>‚úÖ Ready to Proceed?</h2>
            <p>This plan has been reviewed by Codex and major issues addressed. The implementation uses <strong>CSS Highlights API</strong> as the primary approach (non-invasive, paint-layer) with a <strong>DOM wrapping fallback</strong> for browsers without support.</p>
            <p><strong>Estimated Timeline:</strong> 4 days</p>
            <ul>
                <li>Day 1: Detection & activation (context menu, keyboard)</li>
                <li>Day 2: CSS Highlights API implementation</li>
                <li>Day 3: Integration with InlineChatWindow</li>
                <li>Day 4: Cleanup, edge cases, testing</li>
            </ul>
            <p><strong>Risk Level:</strong> Medium (CSS Highlights API reduces DOM mutation risks)</p>
        </div>
    </div>

    <script>
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('open');
        }

        function expandAll() {
            document.querySelectorAll('.collapsible').forEach(el => {
                el.classList.add('open');
            });
        }

        function collapseAll() {
            document.querySelectorAll('.collapsible').forEach(el => {
                el.classList.remove('open');
            });
        }
    </script>
</body>
</html>
